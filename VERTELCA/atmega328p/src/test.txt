#include <Arduino.h>               // Подключаем базовую библиотеку Arduino для функций setup(), loop(), millis() и т.д.
#include <SoftwareSerial.h>        // Подключаем библиотеку SoftwareSerial для создания программного последовательного порта

// Определяем константы протокола обмена данными
#define HEADER 0xAA                // Заголовок пакета; сигнализирует о начале пакета
#define ACK    0x55                // Значение байта подтверждения (ACK)
#define NACK   0xFF                // Значение байта отрицательного подтверждения (NACK)

// Определяем флаг, обозначающий, что пакет требует подтверждения (ACK)
#define FLAG_NEEDS_ACK 0x01        // Если установлен, пакет требует подтверждения

// Создаём объект SoftwareSerial для ATmega328p на пинах 10 (RX) и 11 (TX)
// Это позволяет использовать аппаратный Serial для отладки
SoftwareSerial softSerial(10, 11);

// Перечисление возможных состояний протокола
enum ProtocolState {
  STATE_IDLE,                    // Нет активной передачи, устройство находится в состоянии ожидания
  STATE_WAIT_ACK                 // Пакет отправлен, устройство ожидает подтверждения (ACK или NACK)
};

// Объявляем тип для внешнего обработчика полезных данных (callback)
// Функция-обработчик принимает указатель на массив данных и его длину
typedef void (*DataHandler)(const uint8_t *data, uint8_t length);

// Класс SerialProtocol реализует асинхронный обмен данными по заданному протоколу
class SerialProtocol {
public:
  // Конструктор класса, принимает ссылку на объект SoftwareSerial и инициализирует переменные
  SerialProtocol(SoftwareSerial &serial)
    : serial(serial),            // Сохраняем ссылку на SoftwareSerial
      state(STATE_IDLE),         // Устанавливаем начальное состояние как STATE_IDLE
      ackTimeout(0),             // Инициализируем таймаут ожидания ACK значением 0
      rxIndex(0),                // Сбрасываем индекс буфера приёма (начинаем с 0)
      packetReady(false),        // Флаг, что пакет ещё не получен
      dataHandler(NULL)          // Изначально внешний обработчик не установлен (NULL)
  { }

  // Метод begin() инициализирует SoftwareSerial на указанной скорости (baud rate)
  void begin(unsigned long baudRate) {
    serial.begin(baudRate);      // Запускаем SoftwareSerial на заданной скорости
  }

  // Метод для регистрации внешнего обработчика полученных данных
  // handler - функция, которая будет вызываться при получении полезных данных
  void setDataHandler(DataHandler handler) {
    dataHandler = handler;       // Сохраняем указатель на внешнюю функцию-обработчик
  }

  // Метод sendPacketNonBlocking() отправляет пакет данных асинхронно и (при необходимости) ожидает подтверждения
  // data     - указатель на массив полезных данных
  // length   - длина полезной нагрузки (количество байт)
  // needsAck - если true, пакет требует подтверждения (ACK)
  void sendPacketNonBlocking(uint8_t *data, uint8_t length, bool needsAck) {
    // Формируем пакет по следующему формату:
    // [HEADER] [LENGTH] [FLAGS] [DATA (N байт)] [CRC]
    // Размер пакета = длина данных + 4 байта (HEADER, LENGTH, FLAGS, CRC)
    uint8_t packet[length + 4];         // Создаём массив для формирования пакета нужного размера

    packet[0] = HEADER;                 // Устанавливаем заголовок пакета
    packet[1] = length;                 // Записываем длину полезной нагрузки
    // Устанавливаем флаг: если пакет требует подтверждения, записываем FLAG_NEEDS_ACK, иначе 0x00
    packet[2] = needsAck ? FLAG_NEEDS_ACK : 0x00;
    memcpy(&packet[3], data, length);   // Копируем полезные данные в пакет, начиная с 4-го байта (индекс 3)
    // Вычисляем CRC для всех байтов пакета, кроме последнего, и записываем её в последний байт
    packet[length + 3] = crc8(packet, length + 3);

    serial.write(packet, length + 4);   // Отправляем сформированный пакет по SoftwareSerial

    // Если пакет требует подтверждения, переходим в состояние ожидания подтверждения
    if (needsAck) {
      state = STATE_WAIT_ACK;           // Устанавливаем состояние как STATE_WAIT_ACK
      ackTimeout = millis() + 1000;       // Устанавливаем таймаут ожидания ACK на 1000 мс (1 секунда)
    }
    // Если подтверждение не требуется, состояние остается STATE_IDLE
  }

  // Метод update() вызывается в основном цикле (loop) для асинхронной обработки:
  // - Чтения входящих байтов из SoftwareSerial
  // - Формирования входящего пакета
  // - Обработки полученного пакета (подтверждения или данных)
  // - Управления состоянием ожидания подтверждения (проверка таймаута)
  void update() {
    // Читаем все доступные байты из SoftwareSerial
    while (serial.available() > 0) {          // Пока доступны байты для чтения
      uint8_t byte = serial.read();           // Считываем один байт из SoftwareSerial
      // Если это первый байт пакета и он не равен HEADER, пропускаем его (возможно, это шум)
      if (rxIndex == 0 && byte != HEADER) {
        continue;                           // Переходим к следующему байту
      }
      rxBuffer[rxIndex++] = byte;             // Сохраняем полученный байт в буфер и увеличиваем индекс

      // Если получено не менее 4-х байт (минимальный размер пакета) и
      // если общее количество байтов равно [LENGTH] + 4 (HEADER, LENGTH, FLAGS, DATA, CRC),
      // тогда пакет полностью получен
      if (rxIndex > 3 && rxIndex == rxBuffer[1] + 4) {
        packetReady = true;                 // Устанавливаем флаг, что пакет готов к обработке
      }
    }

    // Если получен полный пакет, обрабатываем его
    if (packetReady) {
      packetReady = false;                  // Сбрасываем флаг готовности пакета для приема следующего
      uint8_t length = rxBuffer[1];           // Извлекаем длину полезной нагрузки (второй байт)
      uint8_t flags = rxBuffer[2];            // Извлекаем байт флагов (третий байт)
      uint8_t receivedCrc = rxBuffer[length + 3]; // Извлекаем полученную CRC из последнего байта пакета
      // Вычисляем контрольную сумму для всех байтов пакета, кроме последнего (от HEADER до DATA)
      uint8_t calculatedCrc = crc8(rxBuffer, length + 3);

      // Если полученная и вычисленная CRC совпадают, пакет корректен
      if (receivedCrc == calculatedCrc) {
        // Если устройство находится в состоянии ожидания подтверждения
        // и пакет является подтверждением (полезная нагрузка имеет длину 1 и равна ACK)
        if (state == STATE_WAIT_ACK && length == 1 && rxBuffer[3] == ACK) {
          Serial.println("ACK received.");    // Выводим сообщение о получении ACK
          state = STATE_IDLE;                 // Сбрасываем состояние ожидания
        }
        // Если устройство находится в состоянии ожидания подтверждения и пакет равен NACK
        else if (state == STATE_WAIT_ACK && length == 1 && rxBuffer[3] == NACK) {
          Serial.println("NACK received.");   // Выводим сообщение о получении NACK
          state = STATE_IDLE;                 // Сбрасываем состояние ожидания (можно добавить повторную отправку)
        }
        // Если пакет не является подтверждением, проверяем, требует ли он отправки ACK
        else if (flags & FLAG_NEEDS_ACK) {
          Serial.println("Received command packet requiring ACK."); // Выводим сообщение о получении пакета, требующего подтверждения
          // Отправляем подтверждение (ACK) для полученного пакета
          uint8_t ackPayload[] = { ACK };      // Формируем полезную нагрузку для ACK
          sendPacketNonBlocking(ackPayload, 1, false); // Отправляем ACK без необходимости повторного подтверждения
        }
        // Если пакет не является подтверждением и не требует автоматического ACK,
        // то вызываем внешний обработчик полезных данных, если он зарегистрирован
        else {
          Serial.println("Received command packet."); // Выводим сообщение о получении команды/данных
          // Если внешний обработчик установлен (не равен NULL)
          if (dataHandler) {
            // Вызываем обработчик и передаем ему указатель на полезные данные и их длину
            // Полезные данные находятся в буфере, начиная с индекса 3, длина равна length
            dataHandler(&rxBuffer[3], length);
          }
        }
      }
      // Если CRC не совпадает, выводим сообщение об ошибке
      else {
        Serial.println("CRC error in received packet.");
      }
      rxIndex = 0;  // Сбрасываем индекс буфера приёма для нового пакета
    }

    // Если устройство находится в состоянии ожидания подтверждения (STATE_WAIT_ACK)
    // и время ожидания превышено, сбрасываем состояние и выводим сообщение о таймауте
    if (state == STATE_WAIT_ACK && millis() > ackTimeout) {
      Serial.println("Timeout waiting for ACK."); // Выводим сообщение о таймауте
      state = STATE_IDLE;                         // Сбрасываем состояние
      // Можно добавить логику повторной отправки пакета, если необходимо
    }
  }

private:
  SoftwareSerial &serial;       // Ссылка на объект SoftwareSerial для обмена данными
  ProtocolState state;          // Текущее состояние протокола (STATE_IDLE или STATE_WAIT_ACK)
  unsigned long ackTimeout;     // Время (в мс), до которого ожидается подтверждение (ACK)
  uint8_t rxBuffer[32];         // Буфер для хранения входящих байтов пакета
  uint8_t rxIndex;              // Индекс текущей позиции в буфере приёма
  bool packetReady;             // Флаг, указывающий, что пакет полностью получен и готов к обработке
  DataHandler dataHandler;      // Внешний обработчик полученных данных (callback-функция)

  // Метод crc8() вычисляет контрольную сумму CRC-8 для входного массива данных
  // data - указатель на массив данных, len - длина массива, для которого вычисляется контрольная сумма
  uint8_t crc8(const uint8_t *data, uint8_t len) {
    uint8_t crc = 0;            // Инициализируем переменную CRC нулём
    while (len--) {             // Пока не обработаны все байты в массиве
      uint8_t inbyte = *data++; // Считываем текущий байт и переходим к следующему
      for (uint8_t i = 8; i; i--) {  // Обрабатываем каждый из 8 бит текущего байта
        uint8_t mix = (crc ^ inbyte) & 0x01;  // Вычисляем младший бит XOR между CRC и текущим байтом
        crc >>= 1;              // Сдвигаем CRC вправо на 1 бит
        if (mix) crc ^= 0x8C;   // Если mix равен 1, выполняем операцию XOR с полиномом 0x8C
        inbyte >>= 1;           // Сдвигаем текущий байт вправо на 1 бит
      }
    }
    return crc;                 // Возвращаем вычисленное значение CRC
  }
};

// Создаём глобальный объект протокола, передавая ему объект softSerial
SerialProtocol protocol(softSerial);

void setup() {
  Serial.begin(115200);        // Инициализируем аппаратный последовательный порт для отладки
  protocol.begin(9600);        // Инициализируем SoftwareSerial для обмена данными на скорости 9600 бод

  // Пример: регистрация внешнего обработчика полученных данных
  // Функция myDataHandler будет вызываться при получении пакета с полезными данными
  protocol.setDataHandler([](const uint8_t *data, uint8_t length) {
    // Обработчик выводит полученные данные в монитор порта
    Serial.print("Data received: ");
    for (uint8_t i = 0; i < length; i++) {
      Serial.print(data[i], HEX);   // Вывод каждого байта в шестнадцатеричном формате
      Serial.print(" ");
    }
    Serial.println();
  });
}

void loop() {
  protocol.update();  // Вызываем метод update() для асинхронной обработки входящих данных и управления протоколом

  // Здесь можно выполнять другие задачи, не блокируя основной цикл
}
