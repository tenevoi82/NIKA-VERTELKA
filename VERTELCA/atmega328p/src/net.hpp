#include <Arduino.h>        // Подключаем основную библиотеку Arduino с базовыми функциями
#include <SoftwareSerial.h> // Подключаем библиотеку SoftwareSerial для создания программного последовательного порта

// Определяем константы протокола обмена данными
#define HEADER 0xAA // Заголовок пакета, который сигнализирует о начале пакета
#define ACK 0x55    // Значение байта подтверждения (ACK)
#define NACK 0xFF   // Значение байта отрицательного подтверждения (NACK)

// Определяем флаг пакета, обозначающий, что пакет требует подтверждения (ACK)
#define FLAG_NEEDS_ACK 0x01 // Флаг, если установлен, означает, что пакет требует подтверждения

// Перечисляем возможные состояния протокола обмена
enum ProtocolState
{
    STATE_IDLE,    // Состояние простоя: нет активной передачи, устройство ожидает действия
    STATE_WAIT_ACK // Состояние ожидания подтверждения: пакет отправлен, ждём подтверждения (ACK или NACK)
};

// Класс SerialProtocol реализует асинхронный обмен данными по протоколу
class SerialProtocol
{
public:
    // Конструктор принимает ссылку на объект SoftwareSerial и инициализирует внутренние переменные
    SerialProtocol(SoftwareSerial &serial)
        : serial(serial),    // Инициализируем ссылку на SoftwareSerial
          state(STATE_IDLE), // Устанавливаем начальное состояние протокола как STATE_IDLE (ожидание)
          ackTimeout(0),     // Инициализируем таймаут ожидания подтверждения значением 0
          rxIndex(0),        // Инициализируем индекс буфера приёма равным 0
          packetReady(false) // Изначально пакет не готов к обработке (флаг = false)
    {
    }

    void SetListener(bool (*handler)(uint8_t[], uint8_t))
    {
        this->handler = handler;
    }

    unsigned long ackTimeout_ms = 1000; // Время (в миллисекундах) до которого ожидаем подтверждения (ACK)

    // Метод begin() инициализирует SoftwareSerial на заданной скорости (baud rate)
    void begin(unsigned long baudRate)
    {
        serial.begin(baudRate); // Запускаем программный последовательный порт с указанной скоростью
    }

    // Немедленная (неблокирующая) отправка пакета с указанием, требует ли он подтверждения
    // data      - указатель на массив с полезными данными, которые нужно отправить
    // length    - длина полезной нагрузки (количество байт)
    // needsAck  - булевское значение: true, если пакет должен требовать подтверждения, иначе false
    void sendPacketNonBlocking(uint8_t *data, uint8_t length, bool needsAck)
    {
        // Формируем пакет: структура пакета будет следующей:
        // [HEADER] [LENGTH] [FLAGS] [DATA (N байт)] [CRC]
        // Размер пакета = длина данных + 4 байта (HEADER, LENGTH, FLAGS, CRC)
        uint8_t packet[length + 4]; // Выделяем массив для формирования пакета нужного размера

        packet[0] = HEADER; // Записываем заголовок пакета в первый байт массива
        packet[1] = length; // Записываем длину полезных данных во второй байт массива
        // Записываем флаг: если пакет требует подтверждения, устанавливаем FLAG_NEEDS_ACK, иначе записываем 0x00
        packet[2] = needsAck ? FLAG_NEEDS_ACK : 0x00;
        memcpy(&packet[3], data, length); // Копируем полезную нагрузку в пакет, начиная с 4-го байта (индекс 3)
        // Вычисляем CRC для пакета (от HEADER до последнего байта данных) и записываем в последний байт
        packet[length + 3] = crc8(packet, length + 3);

        // Отправляем сформированный пакет через SoftwareSerial
        serial.write(packet, length + 4);

        // Если пакет требует подтверждения, переходим в состояние ожидания подтверждения
        if (needsAck)
        {
            state = STATE_WAIT_ACK;                // Устанавливаем состояние протокола как ожидание подтверждения
            ackTimeout = millis() + ackTimeout_ms; // Устанавливаем таймаут ожидания ACK на 1000 миллисекунд (1 секунда)
        }
        // Если пакет не требует подтверждения, состояние остаётся STATE_IDLE
    }

    // Метод update() вызывается в основном цикле (loop) и отвечает за:
    // - Считывание входящих данных из SoftwareSerial
    // - Формирование входящего пакета из полученных байтов
    // - Обработку полученного пакета (подтверждений, команд и т.д.)
    // - Управление состоянием ожидания подтверждения (проверка таймаута)
    void update()
    {
        // Читаем все доступные байты из программного последовательного порта
        while (serial.available() > 0)
        {                                 // Пока в SoftwareSerial имеются байты для чтения
            uint8_t byte = serial.read(); // Считываем один байт из SoftwareSerial
            // Если это первый байт пакета и он не равен HEADER, пропускаем его (это может быть мусор)
            if (rxIndex == 0 && byte != HEADER)
            {
                continue; // Переходим к следующему байту
            }
            // Сохраняем прочитанный байт в буфер приема
            rxBuffer[rxIndex++] = byte;

            // Если получено как минимум 4 байта (минимальный размер пакета)
            // и если общее количество полученных байтов равно [LENGTH] + 4,
            // где [LENGTH] записан во втором байте, то пакет полностью получен
            if (rxIndex > 3 && rxIndex == rxBuffer[1] + 4)
            {
                packetReady = true; // Устанавливаем флаг, что пакет готов к обработке
            }
        }

        // Если пакет полностью получен, переходим к его обработке
        if (packetReady)
        {
            packetReady = false;                        // Сбрасываем флаг, чтобы можно было принимать следующий пакет
            uint8_t length = rxBuffer[1];               // Извлекаем длину полезной нагрузки из второго байта пакета
            uint8_t flags = rxBuffer[2];                // Извлекаем байт флагов (третий байт)
            uint8_t receivedCrc = rxBuffer[length + 3]; // Извлекаем полученную CRC из последнего байта пакета
            // Вычисляем CRC для полученных данных (от HEADER до последнего байта данных, без CRC)
            uint8_t calculatedCrc = crc8(rxBuffer, length + 3);

            // Сравниваем полученную CRC с вычисленной для проверки целостности пакета
            if (receivedCrc == calculatedCrc)
            {
                // Если текущее состояние ожидания подтверждения и пакет является подтверждением (один байт данных равен ACK)
                if (state == STATE_WAIT_ACK && length == 1 && rxBuffer[3] == ACK)
                {
                    Serial.println("ACK received."); // Выводим сообщение о получении подтверждения
                    state = STATE_IDLE;              // Сбрасываем состояние, подтверждение получено
                }
                // Если текущее состояние ожидания подтверждения и пакет является отрицательным подтверждением (NACK)
                else if (state == STATE_WAIT_ACK && length == 1 && rxBuffer[3] == NACK)
                {
                    Serial.println("NACK received."); // Выводим сообщение об отрицательном подтверждении
                    state = STATE_IDLE;               // Сбрасываем состояние (здесь можно добавить логику повторной отправки)
                }
                // Если полученный пакет не является подтверждением, проверяем, требует ли он подтверждения
                else if (flags & FLAG_NEEDS_ACK)
                {
                    // Если флаг установлен, значит полученный пакет требует отправки подтверждения
                    //Serial.println("Received command packet requiring ACK."); // Выводим сообщение о получении команды с требованием подтверждения
                    if (handler != nullptr)
                    {
                        if (handler(&rxBuffer[3], length))
                        {                                 // Вызываем обработчик, если установлен
                            uint8_t ackPayload[] = {ACK}; // Формируем полезную нагрузку для ACK (один байт, равный ACK)
                            // Отправляем подтверждение, используя асинхронную отправку (неблокирующая)
                            sendPacketNonBlocking(ackPayload, 1, false);
                        }
                        else
                        {
                            uint8_t ackPayload[] = {NACK}; // Формируем полезную нагрузку для ACK (один байт, равный ACK)
                            // Отправляем подтверждение, используя асинхронную отправку (неблокирующая)
                            sendPacketNonBlocking(ackPayload, 1, false);
                        }
                    }
                    else
                    {
                        uint8_t ackPayload[] = {NACK}; // Формируем полезную нагрузку для ACK (один байт, равный ACK)
                        // Отправляем подтверждение, используя асинхронную отправку (неблокирующая)
                        sendPacketNonBlocking(ackPayload, 1, false);
                    }
                }
                // Если пакет не является подтверждением и не требует его, обрабатываем его как обычную команду/данные
                else
                {
                    Serial.println("Received command packet."); // Выводим сообщение о получении команды без требования подтверждения
                                                                // Здесь можно добавить дополнительную обработку полученных данных/команды
                    if (handler)
                        handler(&rxBuffer[3], length); // Вызываем обработчик, если установлен
                }
            }
            // Если CRC не совпадает, выводим сообщение об ошибке
            else
            {
                Serial.println("CRC error in received packet.");
            }
            // Сбрасываем индекс буфера приема для начала формирования нового пакета
            rxIndex = 0;
        }

        // Если устройство находится в состоянии ожидания подтверждения, проверяем, не истёк ли таймаут ожидания
        if (state == STATE_WAIT_ACK && millis() > ackTimeout)
        {
            Serial.println("Timeout waiting for ACK."); // Выводим сообщение, что время ожидания подтверждения истекло
            state = STATE_IDLE;                         // Сбрасываем состояние, так как ожидание завершено
                                                        // При необходимости можно добавить здесь логику повторной отправки пакета
        }
    }

private:
    SoftwareSerial &serial;   // Ссылка на объект SoftwareSerial для обмена данными
    ProtocolState state;      // Переменная, хранящая текущее состояние протокола (STATE_IDLE или STATE_WAIT_ACK)
    unsigned long ackTimeout; // Время (в миллисекундах), до которого ожидается подтверждение ACK
    uint8_t rxBuffer[32];     // Буфер для хранения входящих байтов пакета
    uint8_t rxIndex;          // Индекс текущей позиции в буфере приёма
    bool packetReady;         // Флаг, указывающий, что пакет полностью получен и готов к обработке

    bool (*handler)(uint8_t[], uint8_t) = nullptr; // Указатель на функцию

    // Метод crc8() вычисляет контрольную сумму CRC-8 для входного массива данных
    // data - указатель на массив данных, len - длина массива, для которого вычисляется контрольная сумма
    uint8_t crc8(const uint8_t *data, uint8_t len)
    {
        uint8_t crc = 0; // Инициализируем переменную CRC нулём
        while (len--)
        {                             // Пока не обработаны все байты массива (len уменьшается до 0)
            uint8_t inbyte = *data++; // Читаем текущий байт из массива и переходим к следующему
            for (uint8_t i = 8; i; i--)
            {                                        // Обрабатываем 8 бит текущего байта
                uint8_t mix = (crc ^ inbyte) & 0x01; // Вычисляем mix: младший бит результата XOR между CRC и текущим байтом
                crc >>= 1;                           // Сдвигаем CRC вправо на 1 бит
                if (mix)
                    crc ^= 0x8C; // Если mix равен 1, выполняем операцию XOR с полиномом 0x8C
                inbyte >>= 1;    // Сдвигаем текущий байт вправо на 1 бит
            }
        }
        return crc; // Возвращаем вычисленное значение контрольной суммы CRC
    }
};

// // Создаём объект SoftwareSerial для ATmega328p на пинах 10 (RX) и 11 (TX)
// // Обычно на ATmega328p аппаратный Serial используется для отладки, поэтому здесь программный порт позволяет использовать другой канал для связи
// SoftwareSerial softSerial(10, 11);

// // Создаём глобальный объект протокола, передавая ему ранее созданный объект softSerial
// SerialProtocol protocol(softSerial);

// void setup() {
//   Serial.begin(115200);        // Инициализируем аппаратный последовательный порт для вывода отладочной информации
//   protocol.begin(9600);        // Инициализируем SoftwareSerial для обмена данными на скорости 9600 бод
// }

// void loop() {
//   // Вызываем метод update() для асинхронной обработки входящих пакетов,
//   // проверки таймаута ожидания подтверждения и управления состоянием протокола
//   protocol.update();

//   // Здесь можно выполнять и другие задачи, не блокируя основной цикл
// }
